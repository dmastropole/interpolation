% Function ppsmooth
%
% The current version uses an adaptation of the old Plot+ smooth
% routine to do an alternating, in-place 1 point Laplacian algorithm,
% with missing values excluded (sort of).
% z = z + 0.25*(average (zn, ze, zs, zw) - z)
% From Oceanography, EMR Oct 1969.
%
% Originally I put in a thing to smooth the same as Matlab did the
% DEL2 operator.  It was out of date within a week as I originally
% implemented the 5.1.0 version as filter_type='l'. With the release
% of version 5.1.2 they changed the way the edge or boundary
% conditions were implemented, resulting in filter_type='d'.
% filter_type = 'l'   take forward differences on edges based on a
%                     third order approximation.
% filter_type = 'd'   does something different, extrapolated centered
%                     second differences or some such thing.
% The release of 6.1.0 indicates the code DEL2 code has a new revision
% date but fortunately the code is the same.
%
% function [ZOUT, grd_struct] = ppsmooth (ZIN, grd, command)
% Inputs:
%    ZIN      - the {row,col} matrix of z z values, perhaps generated by
%               the routine ppzinit, but anything should work.
%    grd      - a structure whose elements are defined below.  This is a
%               returned parameter if ppzinit was used.
%                It may be used to generate a meshgrid.
%                struct ('x_min', xmin, ...
%                        'x_max', xmax, ...
%                        'y_min', ymin, ...
%                        'y_max', ymax, ...
%                        'x_inc', DX, ...
%                        'y_inc', DY, ...
%                        'nx', NX, ...
%                        'ny', NY, ...
%                        'missing', empty, ...
%                        'masked', mask_val);
%    command   - is the GMT style command.  Some of the options are 
%                detailed below.
%                If the command begins with the identifier 'WIN' the
%                user will be presented with a graphical user interface.
%       command arguments: [-D<distance_flag>]
%           [-E<empty>/<mask_val>]  [-F<type><filter_weight>]
%           [-I<xinc>[/<yinc>] ] [-N]
%           [-R<west/east/south/north>] [-S<smooth_passes>] [-V]
%
%
%        Optional:
%           -D Distance flag determines how grid (x,y) maps into distance units
%              as follows:
%              -D0 grid x,y as node distances, cartesian Distances.
%           -E value to use for empty nodes [Default is NaN].
%              If mask value not specified, default = <empty>.
%           -F sets the filter type and filter_weight.  Choose between
%              (S|s)moothing filter, from Plot+
%              (L|l)aplacian filter, from Matlab 5.10
%              (D|d)el2 Laplacian filter, from Matlab 5.12
%           -I for new Increment of output grid; 
%              enter xinc, optionally xinc/yinc.
%              Default is yinc = xinc.
%              The new xinc and yinc should be divisible by the old;
%              (new lattice is subset of old).
%              NOTE: Smoothing is done after the sub-sampling so there
%                 could be edge effects.
%           -N Force pixel registration for output grid.
%              [Default is gridline registration]
%           -R for new Range of output grid; 
%              enter <WESN> (xmin, xmax, ymin, ymax) separated by slashes.
%               NOTE: Smoothing is done after the sub-region extraction
%                     so there could be edge effects.
%           -S specifies integer smoothing value >= 1. Default: [1]
%           -V Run in verbose mode [OFF].
%
% Returns:
%    Z         - the gridded array of z values.
%    grd_struct- is a structure containing elements which define the grid.
%                the structure is the same variable content as the input
%                but would be updated to reflect any subsampling.




function [ZOUT, grd_struct] = ppsmooth (ZIN, grd, command)
  
     % Some initialization.  A slight difference here as the default 
     % empty and mask values are set to NaN rather than zero, more
     % in keeping with the Matlab environment.
program_id = 'ppsmooth';
disp (['  Entering program '  program_id]);
D_default = 0;
empty_default = nan;
mask_val_default = nan;
F_default = 0;
filter_name = {'Smooth'  'Laplacian'  'Del2'};
Fweight_default = 0.0;
N_default = 1;
S_default = 1;
V_default = 0;

ZOUT = [];
grd_struct = [];

     % For this initial implementation we are making the default,
     % if nothing was specified, the Laplacian filter with a 
     % width of 3 points (or 2 cells).  This means the -F and -D
     % arguments are no longer required, just optional.
filter_width = 2;

distance_flag = D_default;
empty = empty_default;
mask_val = mask_val_default;
filter_type = F_default;
filter_weight = Fweight_default;
one_or_zero = N_default;
nsmooth = S_default; 
lverbose = V_default;



     % Test to see if the command is requested through a user
     % window, via a WINDOW request.
test_command = upper (command);
if (strncmp (test_command, 'WIN', 3) == 1)
  def_tem = [D_default  empty_default  mask_val_default];
  def_tem = [def_tem  F_default  Fweight_default  N_default  S_default];
  command = 'RESET';
  while (strcmp (command, 'RESET') == 1)
    command = ppsmoo_win (ZIN, grd, def_tem);
    disp (['  Generated command: '  command]);
    end  % while command reset.
  end  % if new command;
if (strcmp (command, 'CANCEL') == 1)
  Z = [];
  grd_struct = [];
  return
  end  % if cancel.

     % Process the command.  There were several ways to go about this.
     % I inherently dislike passing lots of arguments in a call list
     % especially when most are optional.  So for compatibility with
     % GMT I will use the command line form.  So what's the next step.
     % I could replicate the GMT switch case stuff but this becomes
     % program specific anyway.  I don't see much saving so I'll
     % play with Matlab a bit and try something else.
     % How much validation is done is sort of arbitrary depending on
     % where I think things could go awry.
lc = length (command);
argerr = 0;

     % The -D distance.
iarg = findstr (command, '-D');
if (~isempty (iarg) )
  [tema, retn] = sscanf (command(iarg+2:lc), '%d', 1);
  if (retn ~= 1)
    fprintf (2, '  *** %s:  INVALID -D OPTION.\n', program_id);
    fprintf (2, '      DEFAULT VALUE USED (%d).\n',  D_default);
    distance_flag = D_default;
   else
    if (tema(1) ~= 0)
      fprintf (2, '  *** %s: SYNTAX ERROR -D option:  Must be 0 for now\n', ...
           program_id);
      argerr = 1;
     else
      distance_flag = tema(1);
     end  % if
    end  % if retn check.
 else
  distance_flag = D_default;
 end  % if distance argument.

     % The -E empty fill values.
iarg = findstr (command, '-E');
if (~isempty (iarg) )
  if (iarg+2 > lc)
    fprintf (2, '  *** %s:  INVALID -E OPTION.\n', program_id);
    argerr = 1;
   elseif (command(iarg+2) == ' ')
    fprintf (2, '  *** %s:  INVALID -E OPTION.\n', program_id);
    argerr = 1;

   else
    [eopt_str, retn] = sscanf (command(iarg+2:lc), '%s');
    if (eopt_str(1) == 'N'  |  eopt_str(1) == 'n')
      empty = nan;
     else
      [tema, retn] = sscanf (command(iarg+2:lc), '%f', 1);
      empty = tema(1);
     end  % NaN or value check.

    iarg_mask = findstr (eopt_str, '/');
    if (~isempty (iarg_mask) )
      if (iarg_mask+1 > length (eopt_str) )
        mask_val = empty;
       elseif (eopt_str(iarg_mask+1) == 'N'  |  eopt_str(iarg_mask+1) == 'n')
        mask_val = nan;
       else 
        tema = sscanf (eopt_str(iarg_mask+1:length(eopt_str)), '%f', 1);
        mask_val = tema(1);
        end % mask value
     else
      mask_val = empty;
     end  % if mask string.
    end  % if not void.

 else
  empty = empty_default;
  mask_val = mask_val_default;
 end  % if empty fill argument.

     % The -F filter type.
iarg = findstr (command, '-F');
if (~isempty (iarg) )
  [tema, retn] = sscanf (command(iarg+2:lc), '%c', 1);
  if (tema == 'S'  |  tema == 's')  filter_type = 0;
   elseif (tema == 'L'  |  tema == 'l')  filter_type = 1;
   elseif (tema == 'D'  |  tema == 'd')  filter_type = 2;
   else
    fprintf (2, '  *** %s:  INVALID -F OPTION.\n', program_id);
    fprintf (2, '      Using default %d  (%s).\n', ...
             F_default, char(filter_name(F_default+1)) );
   end  % if filter_type
  iarg2 = findstr (command(iarg+3:lc), ' ');
  if (~isempty(iarg2)  &  iarg2 > 1)
    [tema, retn] = sscanf (command(iarg+3:lc), '%f', 1);
    filter_weight = tema;
   else
    filter_weight = Fweight_default;
   end  % if there was filter weight.
 else
  filter_type = F_default;
  filter_weight = Fweight_default;
 end  % if smoothing argument.

     % The -I delta, optional for subsampling in this program.
iarg = findstr (command, '-I');
if (~isempty (iarg) )
  [tema, retn] = sscanf (command(iarg+2:lc), '%f/%f', 2);
  if (retn ~= 2)
    if (retn == 1)
      new_increment = 1;
      dx_new = tema(1);
      dy_new = dx_new;
     else
      fprintf (2, '  *** %s:  INVALID -I OPTION.\n', program_id);
      argerr = 1;
      end  % if
   else
    if (tema(1)*tema(2) <= 0.0)
      fprintf (2, '  *** %s:  INVALID -I OPTION.\n', program_id);
      argerr = 1;
     else
      new_increment = 1;
      dx_new = tema(1);
      dy_new = tema(2);
      end  % if
    end  % if retn check.
 else
  new_increment = 0;
  dx_new = 0.0;
  dy_new = 0.0;
 end  % if delta argument.


     % The -N offset.
iarg = findstr (command, '-N');
if (~isempty (iarg) )
  one_or_zero = 0;
 else
  one_or_zero = N_default;
 end  % if offset argument.

new_range = 0;    % set to 1 if -R option.
west_new = 0.0;
east_new = 0.0;
     % The -R range, here optional.
iarg = findstr (command, '-R');
if (~isempty (iarg) )
  [range, retn] = sscanf (command(iarg+2:lc), '%f/%f/%f/%f', 4);
  if (retn ~= 4)
    fprintf (2, '  *** %s:  INVALID -R OPTION.\n', program_id);
    argerr = 1;
   else
    new_range = 1;
   end  % if
 else
  range = [grd.x_min  grd.x_max  grd.y_min  grd.y_max];
 end  % if range argument.
west_new = range(1);
east_new = range(2);
south_new = range(3);
north_new = range(4);


     % The -S smoothing.
iarg = findstr (command, '-S');
if (~isempty (iarg) )
  [tema, retn] = sscanf (command(iarg+2:lc), '%d', 1);
  if (retn ~= 1)
    fprintf (2, '  *** %s:  INVALID -S OPTION.\n', program_id);
    fprintf (2, '                DEFAULT VALUE USED (%d).\n',  S_default);
    nsmooth = S_default;
   else
    if (tema(1) <= 0)
      fprintf (2, '  *** %s: SYNTAX ERROR -S option:  Must be positive\n', ...
           program_id);
      argerr = 1;
     else
      nsmooth = tema(1);
     end  % if
    end  % if retn check.
 else
  nsmooth = S_default;
 end  % if smoothing argument.

     % The -V verbose.
iarg = findstr (command, '-V');
if (~isempty (iarg) )
  lverbose = 1;
 else
  lverbose = V_default;
 end  % if verbose argument.

  
if (distance_flag < 0  |  distance_flag > 0)
  fprintf (2, '  *** s: SYNTAX ERROR -D option:  Choose among {0}\n', ...
           program_id);
  argerr = 1;
  end  % if distance flag error. 

if (argerr > 0)
  return
  end  % if argument errors.


if (filter_weight == 0.0)  
  if (filter_type == 0)  filter_weight = 0.25;
   elseif (filter_type == 1)  filter_weight = 1.00;
   elseif (filter_type == 2)  filter_weight = 1.00;
   end  % if filter_type == 0
  end  % if filter weight = 0.0.

if (filter_type < 0  |  filter_weight == 0.0) 
  fprintf (2, '  *** %s:  SYNTAX ERROR -F option:  Correct syntax:\n', ...
           program_id);
  fprintf (2, '\t-FX<weight>, with X one of {s}, width is filter smoothing weight\n');
  argerr = 1;
  end  % if

if (nsmooth <= 0 ) 
  fprintf (2, '  *** %s: SYNTAX ERROR -S option:  Must be positive\n', ...
           program_id);
  argerr = 1;
  end  % if

     % Initial status evaluation.
if (argerr == 1)  return;  end

  

  % Check range of output area and set i,j offsets, etc.
  % Are they looking for a new range and increments.
if (~new_range)
  west_new = grd.x_min;
  east_new = grd.x_max;
  south_new = grd.y_min;
  north_new = grd.y_max;
  end  % if not new range.

if (~new_increment) 
  dx_new = grd.x_inc;
  dy_new = grd.y_inc;
  end  % if not new increment.

if (west_new < grd.x_min) argerr = 1;
 elseif (east_new > grd.x_max) argerr = 1;
 elseif (south_new < grd.y_min) argerr = 1;
 elseif (north_new > grd.y_max) argerr = 1;
 elseif (dx_new <= 0.0) argerr = 1;
 elseif (dy_new <= 0.0) argerr = 1;
 end
  
if (argerr)
  fprintf(2,'  *** %s: New WESN incompatible with old.\n', program_id);
  end  % if range error.

     % Make sure output grid is kosher 
checkx = mod (east_new-west_new, dx_new)/dx_new;
checky = mod (north_new-south_new, dy_new)/dy_new;
slop = 1.0E-08;
if (west_new >= east_new  | ...
    south_new >= north_new  | ...
    dx_new*dy_new <= 0.0  | ...
    (checkx > slop  &  checkx < 1.0-slop)  | ...
    (checky > slop  &  checky < 1.0-slop) )
    fprintf (2, '  *** %s:  RANGE NOT AN EVEN MULTIPLE OF INCREMENT.\n',  ...
             program_id); 
    fprintf (2, '     x: %f %f  y: %f %f   del: %f %f\n', ...
             west_new, east_new, south_new, north_new, dx_new, dy_new);
    argerr = 1;
  end  % if range checks.

if (argerr > 0)
  return
  end  % if argument errors.


     % We can save time by computing weight matrix once [or once per scanline] 
     % only if new grid spacing is multiple of old spacing 

nx_out = one_or_zero + round ( (east_new - west_new) / dx_new);
ny_out = one_or_zero + round ( (north_new - south_new) / dy_new);
if (filter_type == 2  &  (nx_out < 3  |  ny_out < 3))  
  fprintf(2, '  *** %s: Output array size incompatible with filter type.\n', ...
          program_id);
  end  % if
  
ZOUT = zeros (ny_out, nx_out);
i_origin = zeros (nx_out, 1);

if (one_or_zero == 1)
  xincnew2 = 0.0;
  yincnew2 = 0.0;
  offset = 0.0;
 else
  xincnew2 = 0.5 * dx_new;
  yincnew2 = 0.5 * dy_new;
  offset = 0.5;
 end  % if node or cell.
  

x_scale = 1.0;
y_scale = 1.0;
x_width = filter_width / (1.0 * x_scale);
y_width = filter_width / (1.0 * y_scale);
y_half_width = fix (ceil(y_width) / 2.0);
x_half_width = fix (ceil(x_width) / 2.0);

nx_fil = 2 * x_half_width + 1;
ny_fil = 2 * y_half_width + 1;

if (lverbose)
  fprintf (1, '  %s: Input nx,ny = (%d %d), output nx,ny = (%d %d), filter nx,ny = (%d %d)\n', ...
           program_id, grd.nx, grd.ny, nx_out, ny_out, nx_fil, ny_fil);
  fprintf (1, '  %s: Filter type is %s, weight coefficient = %g.\n', ...
           program_id, char(filter_name(filter_type+1)), filter_weight);
  fprintf (1, '  Using missing/masked value flags {');
  if (isnan (empty) == 1) 
    fprintf (1, 'NaN') 
   else 
    fprintf (1, '%g', empty);
   end  % if empty test
  if (isnan (mask_val) )
    fprintf (1, '/NaN}.\n') 
   else 
    fprintf (1, '/%g}.\n', mask_val);
   end  % if mask test.
  end  % if verbose summary.


     % Compute nearest x output i-indices and shifts once. 
for (i_out = 1:nx_out)
  x_out = west_new + (i_out - 1) * dx_new + xincnew2;
  i_origin(i_out) = fix (floor(((x_out - grd.x_min) / grd.x_inc) + offset));
  end  % for initialization.
     % This is to account for the shift back to 1 base indices with Matlab.
i_origin = i_origin + 1;


     % For filter type 0, the smoothing.  
if (filter_type == 0)
     % Because this is an in-place filter move the sub-sampled output
     % area to the output array.
      
  for (j_out = 1:ny_out)
    y_out = south_new + (j_out - 1) * dy_new + yincnew2;
    j_in = fix (floor(((y_out - grd.y_min) / grd.y_inc) + offset) ) + 1;
      
    for (i_out = 1:nx_out)
      i_in = i_origin(i_out);
      ZOUT(j_out,i_out) = ZIN(j_in,i_in);
      end  % for i_out.
    end  % for j_out.
  
     % Now we can do the filtering  
     % This gets pretty specific for the PlotPlus smooth cartesian, but that's
     % all this is supposes to replicate.  As such we start at the
     % bottom left corner in the Fortran sense.
     % The l_dir variable is supposed to toggle between 1 and 0 to set
     % the direction starting from SW or NE.  Why not a mod (%) function?
     % Again, for compatibility, process columnwise.  Notice that the 
     % subscripts are kept in the Fortran base 1 sense until the last
     % moment when referencing the actual array.
   

  l_coef1 = filter_weight/4.0;
  for (lsmooth = 1:nsmooth)
    nadj(1:4) = 0;
    adj_sum(1:4) = 0.0;
    l_dir = lsmooth - fix (lsmooth/2)*2;
  
    for (i_out = 1:nx_out)
      it = l_dir*i_out + (1 - l_dir)*(nx_out + 1 - i_out);
  
      for (j_out = 1:ny_out)     % to go by image indexing
        jt = l_dir*j_out + (1 - l_dir)*(ny_out + 1 - j_out);
        zij = ZOUT(jt,it);
               % Is the point missing? 
        if (isnan (zij)  |  zij == empty  |  zij == mask_val)  
         else 
          z_ldel = 0.0;
               % Does the x filter stay inside the boundary? 
          if ((it - 1)*(nx_out - it) > 0)
                 % Are the x filter points missing? 
            z1m = ZOUT(jt,it-1);
            z1p = ZOUT(jt,it+1);
            if (isnan (z1m)  |  z1m == empty  |  z1m == mask_val)
             elseif (isnan (z1p)  |  z1p == empty  |  z1p == mask_val)
             else
              zadj = z1m + z1p - 2.0*zij;
              z_ldel = z_ldel + zadj;
              nadj(1) = nadj(1) + 1;
              adj_sum(1) = adj_sum(1) + zadj;
             end
            end  % if point x filter inside boundary. 

            % Does the y filter stay inside the boundary? 
          if ((jt - 1)*(ny_out - jt) > 0)
                 % Are the y filter points missing? 
            z1m = ZOUT(jt-1,it);
            z1p = ZOUT(jt+1,it);
            if (isnan (z1m)  |  z1m == empty  |  z1m == mask_val)
             elseif (isnan (z1p)  |  z1p == empty  |  z1p == mask_val)
             else  
              zadj = z1m + z1p - 2.0*zij;
              z_ldel = z_ldel + zadj;
              nadj(2) = nadj(2) + 1;
              adj_sum(2)= adj_sum(2) + zadj;
             end
            end  % if point y filter inside boundary. 

          zadj = z_ldel;
          zij = zij + l_coef1*zadj;
          ZOUT(jt,it) = zij;
          nadj(3) = nadj(3) + 1;
          adj_sum(3) = adj_sum(3) + zadj;
          end  % for j_out 
        end  % for i_out 
      end  % if valid point.

    if (lverbose) 
      fprintf (2, '  Average {x,y,t}(node) adjustments for smoothing pass %2d.\n', ...
               lsmooth);
      fprintf (2, '    %g(%d)     %g(%d)     %g(%d)\n', ...
               l_coef1*adj_sum(1)/nadj(1), nadj(1), ...
               l_coef1*adj_sum(2)/nadj(2), nadj(2), ...
               l_coef1*adj_sum(3)/nadj(3), nadj(3));
      end  % if verbose
    end  % for lsmooth 


       % Or is it a Laplacian, (per Matlab 5.10). 
 elseif (filter_type == 1)
       % Move the input array to output, then back to input in the new
       % shape for processing.
        
  for (j_out = 1:ny_out)
    y_out = south_new + (j_out - 1) * dy_new + yincnew2;
    j_in = fix (floor(((y_out - grd.y_min) / grd.y_inc) + offset) ) + 1;
      
    for (i_out = 1:nx_out)
      i_in = i_origin(i_out);
      ZOUT(j_out,i_out) = ZIN(j_in,i_in);
      end  % for i_out.
    end  % for j_out.
  
          % Now we can do the filtering  
          % Following are some loops.  Notice that if the point or the filter
          % point was bad we want to set the new output point to be bad.
          % And then continue.  Great for C language but Matlab doesn't
          % allow continue, next or even a nice old goto.  And I hate
          % umpty layers of embedded if conditionals.  So we make some
          % assumptions, for the better I believe.  The C implementation
          % treated empty/masked values other than NaN but could potentially
          % lead to trouble in multiple smoothing passes.  More in keeping
          % with the Matlab environment we will convert indicated flagged
          % values to Nan and then let Matlab have at it.
  iz = find (ZOUT == empty);
  if (~isempty (iz) )  ZOUT(iz) = nan;  end
  iz = find (ZOUT == mask_val);
  if (~isempty (iz) )  ZOUT(iz) = nan;  end
           
  for (lsmooth = 1:nsmooth)
       % If more than one pass, copy back into input. 
    ZIN = ZOUT;
    ZOUT = ZIN + del2_510 (ZIN);
    end  % lsmooth loop. 
 


       % Or is it a Del2 Laplacian, (per Matlab 5.12). 
       % I ask myself:  if I originally took this from Matlab
       % and put it in C why not just go back to calling the
       % Matlab del2 function and get rid of this.  Well, I tried
       % a test and you know what?  The results were identical.
       % How extraordinarily gratifying.  Then I realized I put
       % in all the checking for empty and masked values.  So to
       % revert to the del2 I would probably have to do a find
       % of all flagged values, change to NaNs, do the filter
       % then put back in the masked values.
 elseif (filter_type == 2)
       % Move the input array to output, then back to input in the new
       % shape for processing.
        
  for (j_out = 1:ny_out)
    y_out = south_new + (j_out - 1) * dy_new + yincnew2;
    j_in = fix (floor(((y_out - grd.y_min) / grd.y_inc) + offset) ) + 1;
    
    for (i_out = 1:nx_out)
      i_in = i_origin(i_out);
      ZOUT(j_out,i_out) = ZIN(j_in,i_in);
      end
    end
  
          % Now we can do the filtering  
          % Following are some loops.  Notice that if the point or the filter
          % point was bad we want to set the new output point to be bad.
          % And then continue.  Great for C language but Matlab doesn't
          % allow continue, next or even a nice old goto.  And I hate
          % umpty layers of embedded if conditionals.  So we make some
          % assumptions, for the better I believe.  The C implementation
          % treated empty/masked values other than NaN but could potentially
          % lead to trouble in multiple smoothing passes.  More in keeping
          % with the Matlab environment we will convert indicated flagged
          % values to Nan and then let Matlab have at it.
  iz = find (ZOUT == empty);
  if (~isempty (iz) )  ZOUT(iz) = nan;  end
  iz = find (ZOUT == mask_val);
  if (~isempty (iz) )  ZOUT(iz) = nan;  end

  for (lsmooth = 1:nsmooth)
         % If more than one pass, copy back into input. 
    ZIN = ZOUT;
    ZOUT = ZIN + del2 (ZIN);
    end  % lsmooth loop. 
 end  % filter type selection



if (lverbose) fprintf (2, '\n');  end;


grd_struct = struct ('x_min', west_new, ...
              'x_max', east_new, ...
              'y_min', south_new, ...
              'y_max', north_new, ...
              'x_inc', dx_new, ...
              'y_inc', dy_new, ...
              'nx', nx_out, ...
              'ny', ny_out, ...
              'missing', empty, ...
              'masked', mask_val);

  
     % A nice touch would be to put back in the empty or masked flag
     % values but its beyond this initial implementation.  Besides,
     % it would have to be done e on the resampled areas as well,
     % which would probably mean making sure its tested before
     % the conversion of everything to NaN.
  
return
